#!/usr/bin/env bash
#
# generate.sh — Generate devcontainer .jsonc templates from shared config
#
# Usage:
#   ./generate.sh              # Generate all templates
#   ./generate.sh python       # Generate only python.jsonc
#   ./generate.sh node rust    # Generate node.jsonc and rust.jsonc
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SRC_DIR="${SCRIPT_DIR}/src"
OUT_DIR="${SCRIPT_DIR}"

# Colors (if terminal supports them)
if [ -t 1 ]; then
  GREEN='\033[0;32m'; YELLOW='\033[0;33m'; RED='\033[0;31m'; NC='\033[0m'
else
  GREEN=''; YELLOW=''; RED=''; NC=''
fi

info()  { echo -e "${GREEN}[+]${NC} $*"; }
warn()  { echo -e "${YELLOW}[!]${NC} $*"; }
error() { echo -e "${RED}[-]${NC} $*"; }

find_python() {
  for cmd in python3 python py; do
    if "$cmd" --version &>/dev/null; then
      echo "$cmd"
      return 0
    fi
  done
  return 1
}

PYTHON="$(find_python)" || {
  error "Python not found. Required for template generation."
  exit 1
}

# Determine which languages to generate
ALL_LANGS=(python node rust)
if [[ $# -gt 0 ]]; then
  LANGS=("$@")
  for lang in "${LANGS[@]}"; do
    if [[ ! -f "${SRC_DIR}/${lang}.json" ]]; then
      error "No source file found: src/${lang}.json"
      exit 1
    fi
  done
else
  LANGS=("${ALL_LANGS[@]}")
fi

info "Generating templates: ${LANGS[*]}"
echo ""

ERRORS=0

for lang in "${LANGS[@]}"; do
  OUTPUT="${OUT_DIR}/${lang}.jsonc"
  info "Generating ${lang}.jsonc..."

  "$PYTHON" - "${SRC_DIR}/base.json" "${SRC_DIR}/${lang}.json" "${OUTPUT}" << 'PYEOF'
import json, sys, re
from collections import OrderedDict

base_path, override_path, output_path = sys.argv[1], sys.argv[2], sys.argv[3]

with open(base_path) as f:
    base = json.load(f)

with open(override_path) as f:
    override = json.load(f)

# --- Merge features ---
features = OrderedDict(base.get("features", {}))
for k, v in override.get("additionalFeatures", {}).items():
    features[k] = v

# --- Merge postCreateCommand ---
post_create = OrderedDict(base.get("postCreateCommand", {}))
for k, v in override.get("postCreateCommand", {}).items():
    post_create[k] = v

# --- Convert mount templates to strings ---
remote_user = override["remoteUser"]
mount_strings = []
for m in base.get("mounts", []):
    source_suffix = m["source_suffix"]
    target_suffix = m["target_suffix"]
    mount_type = m["type"]
    options = m.get("options", "")

    source = f"${{localEnv:HOME}}${{localEnv:USERPROFILE}}/{source_suffix}"
    target = f"/home/{remote_user}/{target_suffix}"

    parts = [f"source={source}", f"target={target}", f"type={mount_type}"]
    if options:
        parts.append(options)
    mount_strings.append(",".join(parts))

# --- Assemble output ---
output = OrderedDict()
output["name"] = base["name"]
output["image"] = override["image"]
output["features"] = features
output["customizations"] = override["customizations"]
output["postCreateCommand"] = post_create
output["mounts"] = mount_strings
output["forwardPorts"] = base.get("forwardPorts", [])
output["remoteUser"] = remote_user

# --- Serialize to JSON ---
raw = json.dumps(output, indent=2)

# --- Inject comments ---
comments = override.get("comments", {})
lines = raw.split("\n")

# Inject postCreateCommand comment before that key
if "postCreateCommand" in comments:
    comment_line = comments["postCreateCommand"]
    new_lines = []
    for line in lines:
        if '"postCreateCommand"' in line:
            # Match indentation of the key line
            indent = len(line) - len(line.lstrip())
            new_lines.append(" " * indent + comment_line)
        new_lines.append(line)
    lines = new_lines

# Prepend header comments
header_lines = comments.get("header", [])
auto_gen = "// AUTO-GENERATED by generate.sh — edit src/ files instead"
header_lines = [auto_gen] + header_lines

result = "\n".join(header_lines) + "\n" + "\n".join(lines) + "\n"

# --- Validate by stripping comments and re-parsing ---
stripped = re.sub(r'//.*$', '', result, flags=re.MULTILINE)
try:
    json.loads(stripped)
except json.JSONDecodeError as e:
    print(f"ERROR: Generated output is not valid JSON: {e}", file=sys.stderr)
    sys.exit(1)

# --- Write output ---
with open(output_path, "w", newline="\n") as f:
    f.write(result)

PYEOF

  if [[ $? -eq 0 ]]; then
    info "  -> ${lang}.jsonc written"
  else
    error "  -> ${lang}.jsonc FAILED"
    ERRORS=$((ERRORS + 1))
  fi
done

echo ""
if [[ $ERRORS -gt 0 ]]; then
  error "Generation completed with ${ERRORS} error(s)"
  exit 1
else
  info "All templates generated successfully"
fi
